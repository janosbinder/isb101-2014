<style>
.reveal code .r{
    width:120%
    font:0.8em}
.section .reveal .state-background {
    background: white;}
.section .reveal h1,
.section .reveal p {
    color: black;
    position: relative;
    top: 4%;}
.reveal h1, .reveal h2, .reveal h3 {
  word-wrap: normal;
  -moz-hyphens: none;
}
.small-code pre code {
  font-size: 1em;
}
.midcenter {
    position: fixed;
    top: 50%;
    left: 50%;
}
.reveal .column {
    display:block;
}
</style>

Introduction to R
========================================================
author: Ganna Androsova
date: 2017-01-09
font-family: 'Arial'
transition: fade

What is R?
========================================================

R is a language and environment for **statistical** computing and **graphics**.

Advantages of R:
- FREE software
- easy to download/install/update
- easy to process big files and analyze huge amounts of data
- integrated data visualization tools
- programs can be integrated in the text (for instance, .pdf file will contain then results of calculations, figures, etc. - RMarkdown)

More details on https://www.r-project.org/about.html

What can I do with R?
========================================================
- Data input/import
- Data output/export
- Basic operations (arithmetical, etc)
- Data visualization
- Data analysis
- much more...

How to install R on my PC?
========================================================

- go to http://cran.r-project.org
- choose your system
- choose **base**
- download R
- run the downloaded file

How to start coding?
========================================================

Create a new script with:
<div style="width:70%"><img src="1.png"></img></div>

What is called "inputs"?
========================================================
Inputs are your data, something you will work with further in your program.

Inputs may be:
![](2.png)

Data types in R
========================================================
![](3.png)
Call command **class( )** to see what data you are working with.

Variables in R
========================================================
Let's say your cases are Bob, Fred, Barb, Sue, and Jeff. 

Age, height, weight, race, year in school, and SAT score are called **variables**. 

You would ordinarily put this information into a data frame as follows:

name   |  age | hgt | wgt | race |gender|SAT 
-------|------|-----|-----|------|------|----
Bob    |   21 |  70 | 180 | Cauc |  M   |1080
Fred   |   18 |  67 | 156 |Af.Am |  M   |1210
Barbara|   18 |  64 | 128 |Af.Am |  F   | 840
Sue    |   24 |  66 | 118 | Cauc |  F   |1340
Jeff   |   20 |  72 | 202 |Asian |  M   | 880

Variables in R
========================================================
Numbers, like age and weight, are called **numerical variables**. 

The names of categories that the subject falls into, for example race ad gender, are called **categorical variables**.

Categorical variables are often called **factors** in R.

name   |  age | hgt | wgt | race |gender|SAT 
-------|------|-----|-----|------|------|----
Bob    |   21 |  70 | 180 | Cauc |  M   |1080
Fred   |   18 |  67 | 156 |Af.Am |  M   |1210
Barbara|   18 |  64 | 128 |Af.Am |  F   | 840
Sue    |   24 |  66 | 118 | Cauc |  F   |1340
Jeff   |   20 |  72 | 202 |Asian |  M   | 880

Variables in R
========================================================
When we think of categorical variables or factors, we are thinking of variables that have relatively few possible values. These values are called **levels**. The levels of gender, for example, are F and M.

When a variable has a different value for everyone, like the subject's name or address for example, it's often called a **character variable**.

Assignment
========================================================
class: small-code
In R you create things, called "objects", by a process called **assignment**.

To assign data to an object name in R:
```{r}
x <- 7
```

Here is another way to do assignment:
```{r}
x = 7
```
This SHOULD NOT be read as "x equals 7", which will result in confusion later. Instead, the single equals sign means "takes the value" or "is assigned the value."

Workspace
========================================================
class: small-code
There are several ways to check content of variable:
- Select the variable and press Ctrl+Enter (cmd + Enter for Mac)
- run command
```{r}
print(x)
```
- In R Console type **x** to see it's value.
- Check "Environment" tab in RStudio

As you work in R and create new vectors it can be easy to lose track of what variables you have defined. To get a list of all of the variables that have been defined use the ls() command:
```{r}
ls()
```

Workspace and Files
========================================================
class: small-code

To find what is your working directory:
```{r}
getwd()
```

Check the files that it contains:
```{r}
list.files()
```

Numeric variables
========================================================
class: small-code
Numeric data in R in either "double" or "integer". In practice, numeric computations always produce "double" results thus "numeric" name is used as a synonym. 

Integers are a little more than 2 billion, while the other numerics are much bigger.
They can be bigger because they are stored as double precision floating point numbers, which have two pieces: the exponent (like 308 below), and the "significant" (like 1.797693 below).
```{r}
.Machine$integer.max
.Machine$double.xmax
```

Numeric variables
========================================================
class: small-code
R will automatically convert between the numeric classes when needed.

Most math is done using double precision, so that is often the default storage.
```{r}
is.numeric(1)
is.integer(1)
```

Numeric variables
========================================================
class: small-code
Sometimes you may want to specifically store a vector as integers if you know that they will never be converted to doubles (used as ID values or indexing) since integers require less storage space. 
```{r}
is.numeric(1L)
is.integer(1L) #Putting capital 'L' after an integer forces it to be stored as an integer.
```

Create variable in R
========================================================
class: small-code
- create a new variable based on **a**
```{r}
a <- 2
c <- (a^5 - a)
c
```

Practice time!
========================================================
class: small-code

Type in R console:
```{r, eval = F}
library(swirl)
swirl()
#Lesson 1, 2, 3
```

Choose the "R Programming E" course.
Complete lessons **1, 2**  and **3**. In the end of the lesson send the email to ganna.androsova@uni.lu

The email subject should be generated automaticly by swirl, in the email body place your last command used in the lesson.

Naming of variables
========================================================
Among R naming conventions, the period.separated lowercase is the most preffered one.

E.g. new.plot, my.list, new.function, transition.matrix...

Give **MEANINGFUL** names:
- **matrix.multiplication** is better than **mult**

Andy Lester declared **The World's Worst Variable Name** to be:

                          data

Of course it's data! That's what variables contain! That's all they ever can contain. It's like you're packing up your belongings to move to a new house, and on the side of the box you write, in big black marker, "things".

Naming of variables
========================================================

Guess: what is the **second** worst variable name?


Naming of variables
========================================================

                          data2
```{r, eval=FALSE}
total <- price * qty
total2 <- total - discount
total2 <- total2 + total * taxrate
total3 <- purchase_order_value + available_credit

if ( total2 < total3 ) {
    print "You can't afford this order.";
}
```

If you're faced with naming something total2, change the existing name to something more specific.

Create a vector in R
========================================================
class: small-code
- create a vector with several elements by command **c(object,object,...)**, which combines objects into a vector
```{r}
a <- c(1,2,3)
a
a <- c(1:3)
a
a + 5
a * 4
```

Basic R operations
========================================================
class: small-code
```{r}
a - 10
sqrt(a)
exp(a)
log(a)
```

Basic R operations
========================================================
class: small-code
We can save the results in another vector called **b** and use parentheses for more complicated expressions:
```{r}
b <- (a + sqrt(a))/(exp(2)+1)
print(b)
a / b
```

Basic R operations
========================================================
class: small-code

While performing operations on vectors, all of the vectors in an expression must be the same length. If the lengths of the vectors differ then you may get an error message, or worse, a warning message and unpredictable results:
```{r, warning = TRUE}
a <- c(1, 2, 3, 4, 5, 6)
#or
a <- 1:6

b <- c(10,11,12) 
a + b
```
R has tendency to recycle data.

Operations with vectors
========================================================
![](4.png)

Operations with vectors
========================================================
class: small-code
```{r}
help(sort)
```

**help** will return a full description of the query command: what it does, what it needs as input, what will be produced in output
```{r}
sort(a, decreasing = FALSE)
sort(a, decreasing = TRUE)
```

Logical
========================================================
class: small-code
Logical binary, two possible values represented by **TRUE** and **FALSE**.

```{r}
a <- c(3, 7, 1, 2, 4)
a > 2
a == 2
!(a <= 3)
```

Find which element is...
========================================================
class: small-code
```{r}
a
which(a > 2)
a[which(a > 2)]
```

Functions to Provide Information about Vectors
========================================================
![](5.png)

Logical Operators
========================================================
![](6.png)

Practice time!
========================================================
class: small-code

Type in R console:
```{r, eval = F}
swirl()
#Lesson 4, 8
```

Choose the "R Programming E" course.
Complete lessons **4**  and **8**. In the end of the lesson send the email to ganna.androsova@uni.lu

The email subject should be generated automaticly by swirl, in the email body place your last command used in the lesson.

Missing Data
========================================================
class: small-code

```{r}
v <- c(1:3, NA, NA, 5:8, NA)
v
is.na(v)
which(is.na(v))
v[!is.na(v)]
```

Subsetting Vectors 
========================================================
class: small-code

R has a few built in vectors. One of these is **LETTERS**.

```{r}
LETTERS
```

How do extract the first element from this (the letter A). Here is how to do it:
```{r}
LETTERS[1]
```
Use the square brakets to subset vectors.

How to get folliwing outputs?
========================================================
class: small-code
```{r}
## [1] "B" "C" "D" "E"
```
```{r}
## [1] "B" "C" "D" "E" "G"
```
```{r}
## [1] "A" "B" "C" "D" "E" "Y"
```

How to get folliwing outputs?
========================================================
class: small-code
```{r}
LETTERS[2:5]
LETTERS[c(2:5, 7)]
LETTERS[c(1:5, length(LETTERS) - 1)]
```

Named vectors
========================================================
class: small-code

We can assign names to vector members.

For example, the following variable v is a character string vector with two members.
```{r}
v = c("Mary", "Sue")
names(v) = c("First", "Last")
v
```
Another way:
```{r}
v = c(First = "Mary", Last = "Sue")
v
```

Named vectors
========================================================
class: small-code

Then we can retrieve the first member by its name.
```{r}
v["First"] 
```
Or reverse the order with a character string index vector.
```{r}
v[c("Last", "First")] 
```

Practice time!
========================================================
class: small-code

Type in R console:
```{r, eval = F}
swirl()
#Lesson 5, 6
```

Choose the "R Programming E" course.
Complete lessons **5**  and **6**. In the end of the lesson send the email to ganna.androsova@uni.lu

The email subject should be generated automaticly by swirl, in the email body place your last command used in the lesson.

From vectors to matrices
========================================================
class: small-code
```{r}
a <- c(1,2)
b <- c(3,4)
```

- You may bind two vectors columnwise or rowwise: 
```{r}
cbind(a, b)
c <- rbind(a, b)
```
- But vectors must be of the same length!

From vectors to matrices
========================================================
class: small-code
To create a x-by-y matrix of 0s :
```{r}
matrix(0, nrow = 2, ncol = 3)
```
To create any matrix:
```{r}
matrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3)
```

What is matrix?
========================================================
class: small-code

- A matrix is a two-dimensional data structure. 
- All the elements of a matrix must be of the **same type** (numeric, logical, character, complex).
- It is useful for such data type as gene expression, proteomics data, etc.

![](7.jpg)

Row and column naming
========================================================
class: small-code

Give a vector with names, the length of which corresponds to dimentions of matrix:

```{r}
c <- matrix(c(1,2,3,4,5,6,7,8,9), nrow = 3, ncol = 3)
names <- c("first_row", "second_row", "third_row")
length(names)
rownames(c) <- names
colnames(c) <- c("A", "B", "C")
print(c)
```

Addressing elements
========================================================
class: small-code
To access an element in matrix, specify row index (or row name) and then column index (or name) as **[row_index, col_index]**
```{r}
c
c[1, 2]
c[2, "B"]
```

Addressing elements in matrix
========================================================
class: small-code

Within the brackets you may specify various arguments, including not only numbers, but also conditions to which the desired elements must satisfy:
```{r}
c
c[1,]
c[c>3]
```

Operations with matrix
========================================================
class: small-code
Other operations like **transpose**, **matrix multiplication** can be performed:
```{r}
d <- t(c)
d
c %*% d
```

Operations with matrix
========================================================
class: small-code

Be careful with the * operator: it does not perform matrix multiplication, but rather an entry-wise multiplication:
```{r}
c
d
c * d
```

Data frames
========================================================
class: small-code

A data frame is used for storing data tables. It is a list of vectors of equal length. For example, the following variable df is a data frame containing three vectors n, s, b.
```{r}
numbers <- c(2, 3, 5)
letters <- c("aa", "bb", "cc")
logicals <- c(TRUE, FALSE, TRUE)
df <- data.frame(numbers, letters, logicals)
df
```

What is the difference between matrices and data frames?
========================================================
- Rows and columns of a matrix must have the same class (numeric, character, etc).  
- In a dataframe, you can have mixture of every class.
- You can convert from one to the other using **as.data.frame()** or **as.matrix()**.

WARNING: if you convert a dataframe with different classes of columns, then your matrix will just be all character.

Matrix vs. data frame?
========================================================
class: small-code
R has a built-in data frame called mtcars. Let's take first 5 rows and 5 columns:
```{r}
mtcars[1:5,1:5]
```

Matrix vs. data frame?
========================================================
class: small-code
Now convert it into matrix:
```{r}
as.matrix(mtcars[1:5,1:5])
```
-> nothing changed

Matrix vs. data frame?
========================================================
class: small-code
Change it's first element:
```{r}
mtcars[1,1] <- "text"
```
Now convert it into matrix:
```{r}
as.matrix(mtcars[1:5,1:5])
```
-> all matrix is composed of characters (text)

-> numbers are not recognized as numbers (for algebraic operations) but as text

Data frames
========================================================
class: small-code

We can use the row and column names instead of the numeric coordinates.
```{r}
mtcars["Mazda RX4", "cyl"]
```
The number of data rows in the data frame is given by:
```{r}
nrow(mtcars)
ncol(mtcars) #for number of columns
```

Data frames
========================================================
class: small-code
Access the specific column by **$column_name** (this only works for data frames)
```{r}
mtcars$cyl
mean(mtcars$cyl)
median(mtcars$cyl)
```

Working with data frames
========================================================
class: small-code

```{r}
quantile(mtcars$cyl)
min(mtcars$cyl)
sd(mtcars$cyl)
summary(mtcars[,1:4]) #prints min, max, mean, median, and quantiles
```

Working with data frames
========================================================
class: small-code

Change the column names of data frame with function **names( )**
```{r}
names(mtcars)[1] <- "new_name"
```
To see first n elements of your data frame use **head(data_frame, n)**
```{r}
head(mtcars) #Gives first 6 rows if n is not specified
```

Practice time!
========================================================
class: small-code

Type in R console:
```{r, eval = F}
swirl()
#Lesson 7
```

Choose the "R Programming E" course.
Complete lesson **7**. In the end of the lesson send the email to ganna.androsova@uni.lu

The email subject should be generated automaticly by swirl, in the email body place your last command used in the lesson.

Factors
========================================================
class: small-code
A **factor**-type vector contains a set of numeric codes with character-valued levels. Example, a family of two girls (1) and four boys (0):
```{r}
kids <- factor(c(1,0,1,0,0,0), levels = c(0, 1), labels = c("boy", "girl"))
kids
class(kids)
mode(kids)
```

Factors
========================================================
class: small-code
- great for statistical analysis and exploring the data

However:
- when reading, cleaning, troubleshooting, merging and generally manipulating the data, factors are a total pain
- factors stick around even if you remove some data such that no examples of a particular level still exist

Factors
========================================================
class: small-code
```{r}
x <- as.factor(sample(head(colors()),100,replace=TRUE))
levels(x)
x <- x[x!="aliceblue"]
levels(x) # still the same levels
table(x) # even though one level has 0 entries!
```

Lists
========================================================
class: small-code

An ordered collection of objects (components). A list allows you to gather a variety of (possibly unrelated) objects under one name.
```{r}
# example of a list with 4 components - a string, a numeric vector, a matrix, and a scaler 
mylist <- list(name="Fred", mynumbers=a, mymatrix=c, age=5.3)

# example of a list containing two lists 
two_lists <- list(mylist, list("first_elelment", "second_element"))
```
Identify elements of a list using the [[]] convention
```{r}
mylist[[1]] # 1st component of the list
mylist[["mynumbers"]] # component named mynumbers in list
```

Lists
========================================================
class: small-code
If you have nested lists: indicate with [[]] number of list followed by [] number of element of that list
```{r}
two_lists[[1]][3]
two_lists[[2]][1]
```

Functions
========================================================
class:small-code
```{r}
myfun <- function(x){ 
  return(x*x)
}

myfun(2)
```
If no return() is given, the object last created is returned.

Functions
========================================================
class:small-code
```{r}
myfun <- function(x, a){ 
  r <- a*sin(x) 
  return(r)
} 

#Short version
myfun <- function(x, a){ a*sin(x) }

result <- myfun(pi/2,2)
result
```

Functions
========================================================
class:small-code
Multiple return values have to be returned as a single list.
```{r}
# a is optional parameter with default=1
myfun4 <- function(x, a=1){
  result1 <- a*sin(x)
  result2 <- a*cos(x)
  return(list(result1,result2)) # one list as result
} 
myfun4(pi/2)
```
R doesn't handle return(result1,result2)

Global and local scope
========================================================
![](8.jpg)

Global and local scope
========================================================
class:small-code
```{r}
global.var <- 10

new.fun <- function(x){
  print(paste("Global variable", global.var))
  
  local.variable <- x-3
  print(paste("Local variable", local.variable))
  
  return(local.variable)
}

new.var <- new.fun(global.var)
```

If you print local variable, it is not kept outside of the sunction environment -> error in print(local.variable) : object 'local.variable' not found

```{r, eval=FALSE}
print(local.variable)
```

Practice time!
========================================================
class: small-code

Type in R console:
```{r, eval = F}
swirl()
#Lesson 9
```

Choose the "R Programming E" course.
Complete lesson **9**. In the end of the lesson send the email to ganna.androsova@uni.lu

The email subject should be generated automaticly by swirl, in the email body place your last command used in the lesson.

Control statements: conditions
========================================================
To check whether your data satisfy some particular condition, R has a structure:
**if (expression1) {  expression2 } else { expression3 }**

Here **expression1** must include logical operators and be evaluated to a single logical value (**TRUE** or **FALSE**).

'If TRUE, then the **expression2** is executed.

If FALSE, then **expression3** is executed. The **expression3** may be either a single command, or a sequence of commands, or again a control statement, like if ' else operator or a loop.

Control statements: conditions
========================================================
class:small-code
![](9.png)

```{r}
x <- c(2,3,4,5)

if (all(x) == 0) { 
  x[length(x)+1] <- 5
  print(x) 
} else { 
  x[length(x)+1] <- 16 
  print(x) 
}
```

Repetitive execution: for loop
========================================================
If there's a need in multiple execution of the same command or a sequence of commands, use statement:

**for (xxx in expression1) { expression2 }**

'Here **xxx** is a loop variable; **expression1** is the sequence of instances, which **xxx** should run on and **expression2** is the (group of) command(s) to be executed.

**'expression2** is repeatedly evaluated as xxx ranges through the values in the vector result of expression1.

For loop (example 1)
========================================================
class:small-code
```{r}
mymat <- matrix(nrow=30, ncol=30) # create a 30 x 30 matrix

for(i in 1:dim(mymat)[1]){   # for each row
  for(j in 1:dim(mymat)[2]){ # for each column
    mymat[i,j] <- i*j         # assign a product of two indexes
  }
}  
mymat[1:10, 1:10]
```

For loop (example 2)
========================================================
class:small-code

The Fibonacci numbers have many mathematical relationships and have been discovered repeatedly in nature. They are constructed as the sum of the previous two values, initialized with the values 1 and 1.
```{r}
#Let's calculate 10 Fibonacci numbers
fibvals <- rep(0, 10) #Create vector which will contain 10 values
fibvals[1] <- 1 #Assign 1 to first and second variable
fibvals[2] <- 1
for (i in 3:10) {
   fibvals[i] <- fibvals[i-1]+fibvals[i-2]
} 
fibvals
```

Other loops: repeat and while
========================================================
There exist other statements for repeated expressions: **repeat** expression and **while** (condition) expression.

'The **break** statement can be used to terminate any loop, possibly abnormally. This is the only way to terminate **repeat** loops, usually by using **if'else'** statement to check if the desired condition is satisfied.

'The **next** statement can be used to discontinue one particular cycle and skip to the 'next' (this is more likely to be used in **for** and **while** loops)

While loop
========================================================
class:small-code
**while()** loop will execute a block of commands until the condition is no longer satisfied.
```{r}
x <- 1 
while (x < 4) { 
  x <- x + 1
  print(x) 
}
```

**next** can skip one step of the loop; **break** will end the loop abruptly.
```{r}
x <- 1 
while (x < 4) { 
  x <- x + 1
  if (x == 3){
    next
  }
  print(x) 
}
```

Repeat loop
========================================================
class:small-code
**repeat** is similar to while and for loop, it will execute a block of commands repeatly till break.
```{r}
x <- 0 
repeat { 
  x <- x + 1
  print(x)
  if (x > 5) {
    break
  }
}
```
If no **break** is given, loop runs forever!

The apply() commands
========================================================
these commands allow functions to be run on matrices.

**apply()** function used on matrix
 
**tapply()** table grouped by factors

**lapply()** on lists and vectors; returns a list

**sapply()** like lapply(); returns vector/matrix

**mapply()** multivariate sapply()

apply()
========================================================
class:small-code
**apply(data, margin, function)**
```{r}
a <- matrix(1:10,nrow=2)
apply(a,1,mean) # 1 = by rows
apply(a,2,mean) # 2 = by columns

# the function can also be anonymous
apply(a, 2, function(x){x[[sample.int(length(x),1)]]})
```

lapply() and sapply()
========================================================
class:small-code
**lapply(list, function)**

**sapply(list or vector, function)**
```{r}
a <- matrix(2:11,nrow=2)
b <- matrix(1:10,nrow=2)
c <- list(a,b)

lapply(c,mean)
sapply(c,mean)
```

mapply()
========================================================
class:small-code
Like sapply() but applies over the first elements of each argument

**mapply(FUNCTION, list, list, list...)**
```{r}
mapply(rep, pi, 3:1)

# equivalent to: 
rep(pi, 3) 
rep(pi, 2) 
rep(pi, 1)
```

Vectorization
========================================================
A "vectorized" function **f()** takes a vector [x1, x2, ... , xn] as input and returns the vector [f(x1), f(x2), f(x3), ... , f(xn)].

**Why is vectorization important?**
Vectorized functions usually involve a behind-the-scenes loop in a low-level language (C or Fortran), which runs way faster than a pure R loop.

Vectorization
========================================================
class:small-code
Here's an example using the vectorized log() function that illustrates the speedup you can get:
```{r}
# Create a vector of 1 million random numbers between 1 and 10
nums <- sample(1:10, size=1000000, replace=TRUE) 

# Loop to call log on each vector element separately:
system.time(
  for (x in seq_along(nums)){
    nums[i] <- log(nums[i])
  }
)
system.time(log(nums))
```
So in conclusion: vectorization is important because it allows you to operate on vectors quickly (unlike looping).

Vectorised functions
========================================================
class:small-code
R has **ifelse( )** function that works with vectors:
```{r, warning=TRUE}
x <- c(6:-4)
sqrt(x)  # gives warning
sqrt(ifelse(x >= 0, x, NA))  # no warning
 
## Note: the following also gives the warning !
ifelse(x >= 0, sqrt(x), NA)
```

Vectorised functions
========================================================
Default vectorized matrix functions: 
- **rowSums(), colSums(), rowMeans(), colMeans()**

Vectorized matrix functions in package genefilter:
- **rowSds(), colSds(), rowVars(), colVars(), rowttests(), rowFtests()**

Vectorized matrix functions in package matrixStats:
- **colMedians(), rowMedians()**

Practice time!
========================================================
class: small-code

Type in R console:
```{r, eval = F}
swirl()
#Lesson 10
```

Choose the "R Programming E" course.
Complete lesson **10**. In the end of the lesson send the email to ganna.androsova@uni.lu

The email subject should be generated automaticly by swirl, in the email body place your last command used in the lesson.